------------------ NOTES ------- NOTES ------- NOTES ------------------
Todo: 
		==== DB ====
	- Combine averaging over time workers into one worker
	- Find a resource which contains old data (Vircurex maybe, cryptocharts?)
	- Take into account asset quantity changes over time per user
	- Fetch amounts of assets on each site (bitfunder, btct, btc-e) for each user
	- Starting up logging only writes if time passed from last write is correct.
	- Fill in gaps for 1 minute assets table by averaging surrounding rows
	- Remove 1 minute assets rows which are closer than 30 seconds.
	- Seperate main DB used for filling average tables, short DB containing only
		times and BTC prices for line chart. Preformance reasons.

		==== DB Page ====
	- When Nuking and Averaging tables, show status on website (ajax and shiz)

		==== Homepage ====
	- Homepage on left needs to be more easy to read (Total USD clearer)
	- Ability to represent bar graph in terms of BTC or USD(at the time)
	- Allow homepage assets overview (left side) to update in realtime
	- More charts!
	- Clean up JS for homepage, one seperate file via asset pipeline?
	
		==== MISC ====
	- Public release? Keep quetly on github?
	- Combine all JS into one file via rails asset pipeline(?)
	- Clean up styling for each page (move into CSS file)
	- Remove unused views and controllers.
	- Turbolinks?
	- Links from homepage to DB page and vice versa
	- Clean routes file
	- Use the actual MVC design instead of just using controllers/views
	- Slim for HTML pages?
	- Move worker messeges over to redis?
	- messeges moved to redis instead of postgres?

--------------------------------------------------------------

!!!!--- Pluck returns an un-ordered list ---!!!!
	Therefore, must order the entire friggen table first, then pluck, and then get last which
	makes the list get orederd again anywas. My method sucks, must find better way!
	Check out https://groups.google.com/forum/#!topic/rubyonrails-talk/a8EGtT16qiI for a fix.

SQLITE3 does not handle cuncurrent reads and writes well, making the average old assets method 
	not work due to the method being very parallal (writes at same time). Postgresql handles this
	without any issues, so I am using postgress now instead. Also, holy hell is it faster!

	To setup postgress and migrate data. Read what is under this first though.
	  http://railscasts.com/episodes/342-migrating-to-postgresql?view=asciicast

	Install postgresql via apt-get. Don't bother with the GUI administrative since ubuntu server does
	  not use GUI and interfacing to it over the network is a massive PITA.

	to get postgres bundle working, do
	   sudo apt-get install ruby-dev libpq-dev build-essential

	For setting up postgres with rails
	   http://stackoverflow.com/questions/9987171/rails-3-2-fatal-peer-authentication-failed-for-user-pgerror

	   http://www.davidpashley.com/articles/postgresql-user-administration/ <-- fill out the DB info in rails
	                                           ^^ Create user in postgres
	   http://www.davidpashley.com/articles/postgresql-user-administration/ <-- Give user permission to user for createdb

Sidekiq makes me cry
	- Needs to be able to display worker classes and arguments through sidekiq API
	- Make sure to have the right friggen version of redis running! The sidekiq
		gem installs an outdated 2.2.12 version, so make sure to actually the
		old version first, doing a whereis and whatnot. Fetch the new redis from
		the redis homepage by doing wget and shizzle. Don't bother with apt-get.

	- Needs to be able to stop/cancel workers which are *BUSY*!
		Sidekiq::Queue.new.clear only clears enqueued workers, not busy workers.
		Enqueueeueued is a horric word from the depths of hell. 

	- Sidekiq does not have ability to stop busy workers, even when working
		directly with the redis server and canceling workers with the command
		conn.srem('workers', workers). All other methods of deleting workers
		just deletes workers in a queue, not the busy workers. Therefore, I
		will make my own table for keeping messeges.
		target | messege (stop_imediatly, stop, restart) | from


---- New stuff goes ontop, stop putting it at the bottom! ----
Maybe use an array instead of that horrific long case statement?

	Array[five_min_table, thirty_min_table, hundredtwenty_min_table, threesixty_min_table]

	if five_min_table.not_nil then FiveminuteTimedAsset.new(Array.five_min_table)
	....
	if thirty_min_table.not_nil then ThirtyMinTimedAsset.new(Array.thirty_min_table)


	#minutes = [5, 30, 120, 360]

		#minutes.each{ |minute|
		#		puts "Doing " + minute + " table now"
		#
		#		TimedAsset.count.times do |variable|
		#			puts "This will loop over the entire TimedAsset Table"
		#		end

Just do one damn table first!
First up is doing the 5 minute moving average table

	large_table = TimedAsset.all

	while large_table.count >= 5
		new_table = large_table.shift(5)
		large_5min_table.save(average(new_table, 5))
	end
